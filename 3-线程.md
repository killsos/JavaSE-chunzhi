## 线程

#### 3.1线程的概念
	
3.1.1 进程 是一个正在执行中程序 
	
		每个进程执行都有一个执行顺序  该顺序是一个执行路径 或者叫一个控制单元
	
	线程 还称为 控制单元  执行路径 执行情景
	
		线程就是进程中的一个独立控制单元 线程在控制着进程的执行
	
	
	一个进程中至少一个线程
	
	JAVA VM 虚拟机 启动的时候会有一个进程java.exe
	
	该进程中至少一个线程负责java程序的执行  而却这个线程运行的代码存在于main方法中的

	该线程称之为主线程
	
	还有一个负责垃圾回收的线程 GCC线程 

3.1.2 多线程意义
	
	进程 和 线程 都是调用系统API创建的


#### 3.2 Thread 类

3.2.1 创建线程
	
	1. 将类声明为Thread的子类  重写run方法  start方法完成两个功能 启动线程  调用run方法
	
	2. 声明实现Runnable接口 实现run方法 然后该类的实例 作为创建Thread时的参数来传递并启动
	
	两者区别:
		
		实现方式好处 避免了单继承的局限性
		
		在定义线程时 建立使用实现方式
		
		继承Thread 线程代码存放Thread子类run方法中
		
		实现runnable  线程代码存放接口的子类run方法中
		
3.2.2 为何每次运行结果不同?

	因为多个线程都获取CPU的执行权 CPU执行到谁 谁就运行
	
	明确一点 在某一个时刻 只能有一个程序在运行 也就是只能有一个进程在运行  更是只能有一个线程在运行 (多核除外)
	
	CPU在做着快速的切换  以达到看上去是同时运行的效果
	
	我们可以形象把多线程的运行行为在互相抢夺CPU的执行权
	
	这就是多线程的一个特性: 随机性  谁抢到谁执行  至于执行时长 CPU说了算
	
3.2.3 为何覆盖run方法

	Thread类用于描述线程
	
	该类就定义了一个功能 用于存储线程要执行的代码  该存储功能就是run方法
	
	也就是说Thread类中的run方法 用于存储线程要执行的代码
	
3.2.4 线程状态


						
						阻塞 （具备运行资格  但没有执行权）
						

	 					sleep/wait
	 创建       运行							冻结 
	 					notify
						
						
				消亡
				

3.2.5  线程名称
	
	线程都有默认的名称  Thread-0开始
	
	Thread(String)    构造函数
	
	Thread.currentThread()  返回当前线程
	

3.2.6 线程安全
	
	产生原因
		
		当多条语句在操作同一个线程共享数据时 一个线程对多条语句只执行了一部分 还没有执行完
		
		另一个线程参与进来执行 导致共享数据的错误
		
	解决办法
		
		对多条操作共享数据的语句 只能让一个线程都执行完 在执行过程中 其他线程不可以参与执行
		
		JAVA对于多线程的安全问题提供了专业的解决方法
		
		就是同步代码块  synchronized 关键字  锁  
		
		1. 同步代码块 synchronized (Object p) {
		
		}
		
		2. 同步函数 synchronized function (){}
		
		同步函数用的是哪一个锁？
			
			函数需要被对象调用 那么函数都有一个所属对象引用 就是this
			
			所以同步函数使用的锁就是 this
			
		静态同步函数的是哪一个锁？ 
		
			静态进内存时候 内存没有对象 但是一定有该类对应的字节码文件对象 类名.class
			
			该对象的类型是Class 
			
			所以静态同步函数的锁就是  类名.class
		
		同步前提:
			
			1. 必须要有两个或者两个以上线程
			
			2. 必须是多个线程使用同一个锁
			
		必须保证同步中只能有一个线程运行
		
		好处
			
			解决了多线的安全
		
		弊端
			
			消耗了资源 每次都要判断锁
		
	如何找出多线程同步问题步骤:
	
		1. 明确哪些代码是多线程运行代码
		
		2. 明确共享数据
		
		3. 明确多线程运行代码中哪些语句是操作共享数据的
		
	
	
	
	饿汉与懒汉模式区别:
		
		1. 懒汉是延迟加载  
		
		2. 懒汉延迟加载存在问题是? 多线程访问的时候安全问题
		
			  解决安全问题? 办法是加同步 synchronized
			  	
				加同步存在的问题?  是执行效率问题
				
					解决执行效率问题 办法是加双重判断 
					
			  同步对象是该类所属的字节码文件	 类名，class
	Class single
	{
		private static Single s = null;
		privagte Single(){}
		
		public static Single getInstance (){
			if (s = null) {
				
				synchronized (single.class) {
					if (s = null) {
						s = new Single();
					}
				}
			}
			
			return s;
		}
	}
			  

#### 3.3 死锁
	
3.3.1 死锁概念
	
	Deadlock  或者成为 监视器
	
	当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但是没有一方提前退出时，就称为死锁
	
	同步中嵌套同步 并且彼此使用对方的锁
	
3.3.2 死锁的四个条件是：

	禁止抢占：no preemption

	持有和等待：hold and wait

	互斥：mutual exclusion

	循环等待：circular waiting
					

#### 3.4 进程间通信

3.4.1 概念
	
	其实就是多个线程在同一个资源 但是操作的动作不同
	
	等待唤醒机制
	
	等待的线程都在存在线程池中  notify会唤醒线程池第一个
	
	wait  notify notifyAll 都使用在同步中 因为要对持有监视器(锁)的线程操作
	
	所以要使用在同步中 因为只有同步才具有锁
	
	notify 与 notifyAll 的区别
		
		1. notify		只能唤醒同一个锁的线程
		
		2. notifyAll    会唤醒所有锁的线程
	
	
	为什么这些操作线程的方法要定义Object类中呢？
	
	因为这些方法在操作同步中线程时候 都必须要标识他们所操作线程只有的锁
	
	只有同一个锁上的被等待线程  可以被同一个锁上notify唤醒
	
	不可以对不同锁中的线程进行唤醒
	
	也就是说 等待和唤醒必须是同一个锁
	
	而锁可以是任意对象 所以可以被任意对象调用的方法定义Object类中
	
3.4.2 多线程---生产消|者费者
	
	1. 用while
	
	2. 用notifyAll 唤醒所有等待的线程
	
	
	3. JDK-5 提供Lock接口  用来替代 synchronized 
	
	从JDK5 其实 JDK1.5  以后JDK6 就是 JDK6
		
		0. import .util.concurrent.lock.*
	
		1. Lock lock = new ReentrantLock()
			
		 	new Condition proudce = new Condition();
			
			new Condition resumer = new Condition();
		
		2. lock.lock()
		
		3. try {
			
			proudce.await ();
				... 代码
			
			resumer.singal();  唤醒所有线程
		
		} finally {
			
			lock.unlock();
		}
	
	
3.4.3 停止线程
	
	1. 不要stop方法 低版本的
	
	  通过控制循环来结束线程
	  
	2. 使用interrupt()方法 中断
		
		线程的冻结状态被强制清除
		
	特殊情况
		
		当线程处于冻结状态
		
		就不会读取到编辑 那么线程就不会结束
		
	当没有指定的方式让冻结的线程恢复到运行状态时 这时候需要对冻结进行清除
	
	强制让线程恢复到运行状态中 这样就可以操作标记让线程结束
	
	ThreadL类提供该方法: interrupt()方法
	
	
3.4.4 守护线程
	
	线程.setDaemon(true);
	
	将该线程标记守护线程--true 或 用户线程--false
	
	当正在运行的线程都是守护线程时 Java虚拟机退出
	
	该方法必须在启动线程前调用
	
	该方法首先调用线程的checkAccess方法 且不带任何参数 这可能抛出SerurityException 在当前线程中
	

3.4.5 join()
	
	申请执行权限  临时加入线程执行
	
	相当于主线程遇到join线程就会立即放弃执行权限 介入冻结状态
	
	主线程会等到jonin线程彻底结束后才会复活
	
	
	
	
	
	